{% extends "layout/fullPageScroll.html" %}
{% load static %}  {# Load static files #}
{% load macros %}
{% loadmacros "macros/pagination.html" %}

{% block pageDropDowns %}
  <a href="{% url 'display_company_info' pk=company.id %}">Company Home</a>
{% endblock %}

{% block pageContent %}
  <div class="content-section">
    <h1 class="profile-title">Edit Company Members</h1>
    <form class="form" id="memberForm" method="POST" action="{% url 'edit_company_members' pk=company.id %}">
      {% csrf_token %}
      <input type="hidden" name="page-number" value="{{ page_obj.number }}"/>
      <div class="member-grid">
        {% for user in users %}
          <div>
            <input type="hidden" name="member-checkbox-option" value="{{ user.id }}">
            <input type="checkbox" id="{{ user.id }}" name="member-checkbox" value="{{ user.id }}"
                   {% if user.id in selected_ids %} checked {% endif %} />
            <label for="{{ user.id }}">{{ user.name }}</label>
          </div>
        {% endfor %}
      </div>
      <button class="primary-button" onclick="event.preventDefault(); saveSelectedMembers({{ company.id  }});" type="submit">Save</button>
    </form>
    {% use_macro render_pagination page_obj %}
    {% comment %} Working with/Reworking ideas from Google's AI / Gemini on the checklist selection perservation problem {% endcomment %}
   <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
   <script type="text/javascript">

    const checkedValues = [];
    const uncheckedValues = [];
    const formData = new FormData(document.getElementById('memberForm'));

    const checkboxes = document.querySelectorAll('input[name="member-checkbox"]');


  
    checkboxes.forEach(checkbox => {
      checkbox.addEventListener('change', () => {
        if (checkbox.checked) {
          checkedValues.push(checkbox.value);
          if(uncheckedValues.indexOf(checkbox.value) > -1) {
             uncheckedValues.splice(uncheckedValues.indexOf(checkbox.value), 1);
          }
        } else {
          if(checkedValues.indexOf(checkbox.value) > -1) {
            checkedValues.splice(checkedValues.indexOf(checkbox.value), 1);
          }
          uncheckedValues.push(checkbox.value);
        }
      });
    });



  
{% comment %} const originalUrl = window.location.href;

window.addEventListener('popstate', function() {
    if (window.location.href !== originalUrl) {
        // User navigated using back/forward buttons
        handleNavigationAway();
    }
});

window.addEventListener('click', function(event) {
    if (event.target.tagName === 'A' && event.target.href !== originalUrl) {
        // User clicked a link to a different page
        handleNavigationAway();
    }
}); {% endcomment %}

{% comment %} window.onbeforeunload = handleNavigationAway;


function handleNavigationAway() {
    // Your logic here
  targetHref = event.target.location.href;  
  console.log(targetHref)
  return confirm('User is navigating away');
} {% endcomment %}

{% comment %} Tweak Gemini's suggestion for executing code when the page loads. Trying 
not to keep any unsubmitted user selections when the user navigates away.
This wipeout code isn't foolproof, If you navigate to another page and then hit back you may still have 
your unsaved selections,  but I think that's ok since some other sites seem to behave 
like this
{% endcomment %}
function checkReferringPage() {
  const referrer = document.referrer;

  // Check if the referrer is empty or something other than a page in this editable list of members
  if (!referrer || !referrer.includes('{% url 'edit_company_members' pk=company.id %}')  ) {
    // if we came from anything but another page in this list,  trigger a wipe out of 
    // The users prior selections
    const this_page = document.getElementsByName("page-number");

    fetch('{% url 'edit_company_members' pk=company.id %}?wipe_out=True', {
      method: 'GET'}).then(data => {
       window.location.href = `?page=${this_page}`
      })
  } 
}

window.addEventListener("load", checkReferringPage);


    function saveSelectedMembers(company_id) {
      const selectedUsers = JSON.stringify(checkedValues);
      const deselectedUsers = JSON.stringify(uncheckedValues);
      fetch('{% url 'edit_company_members' pk=company.id %}?selected_users=' + encodeURIComponent(selectedUsers) + '&unselected_users=' + encodeURIComponent(deselectedUsers), {
        method: 'POST'}).then(data => {
          window.location.href = `company/${company_id}/members/`
         })
    }

    function myJavaScriptFunction(page_number) {
      const selectedUsers = JSON.stringify(checkedValues);
      const deselectedUsers = JSON.stringify(uncheckedValues);
      fetch('{% url 'edit_company_members' pk=company.id %}?page=' + page_number + '&selected_users=' + encodeURIComponent(selectedUsers) + '&unselected_users=' + encodeURIComponent(deselectedUsers), {
        method: 'GET'}).then(data => {
         window.location.href = `?page=${page_number}`
        })
    }

    

   </script>


{% endblock %}





